<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SINA vs INNA Split-Screen Visualizer</title>
    
    <!-- Plotly.js for 3D surface plots -->
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    
    <!-- PapaParse for loading CSV files from the server -->
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.3.2/papaparse.min.js"></script>

    <style>
        /* --- CSS Theme Variables --- */
        /* Base styles applied to body */
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Inter", sans-serif;
            background-color: #111827; /* A neutral dark background for the page */
            color: #F3F4F6;
            min-height: 100vh;
            padding: 1rem;
        }

        /* SINA (Florida Tech) Theme - UPDATED */
        .theme-sina {
            --bg-primary: #000000; /* Black */
            --bg-secondary: #1F2937; /* Dark Gray */
            --text-primary: #FFFFFF; /* White */
            --text-secondary: #9CA3AF; /* Medium Gray */
            --accent-primary: #990000; /* Crimson Red */
            --accent-secondary: #D1D5DB; /* Silver */
            --plot-grid: #4B5563;
            --plot-bg: rgba(31, 41, 55, 0.8); /* Semi-transparent for plot */
            transition: background-color 0.3s ease, color 0.3s ease;
        }

        /* INNA (French Flag) Theme */
        .theme-inna {
            --bg-primary: #FFFFFF; /* White */
            --bg-secondary: #F3F4F6; /* Light Gray */
            --text-primary: #111827; /* Dark Gray */
            --text-secondary: #4B5563; /* Medium Gray */
            --accent-primary: #0055A4; /* Blue */
            --accent-secondary: #EF4135; /* Red */
            --plot-grid: #D1D5DB;
            --plot-bg: rgba(255, 255, 255, 0.8); /* Semi-transparent for plot */
            transition: background-color 0.3s ease, color 0.3s ease;
        }

        /* --- Base Styles --- */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        /* --- Layout --- */
        .container {
            max-width: 1600px;
            margin: 0 auto;
        }
        .header {
            text-align: center;
            margin-bottom: 2rem;
        }
        .controls {
            padding: 1.5rem;
            background-color: #1F2937; /* Dark control panel */
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            margin-bottom: 2rem;
            display: flex;
            flex-wrap: wrap;
            gap: 2rem;
            align-items: flex-end;
        }
        .control-group {
            flex-grow: 1;
            min-width: 250px;
        }
        
        .split-container {
            display: flex;
            position: relative;
            width: 100%;
            gap: 2rem; /* Gap between sides */
        }
        
        /* The Lightning Bolt Divider */
        .lightning-divider {
            position: absolute;
            left: 50%;
            top: 0;
            bottom: 0;
            width: 6px;
            transform: translateX(-3px);
            background: #ffffff;
            /* Glowing effect to mimic lightning */
            box-shadow: 0 0 5px #fff, 
                        0 0 10px #fff, 
                        0 0 15px #00ffff, 
                        0 0 20px #00ffff;
            z-index: 10;
        }

        .split-side {
            flex: 1;
            padding: 1.5rem;
            border-radius: 0.5rem;
            background-color: var(--bg-primary);
            color: var(--text-primary);
            display: flex;
            flex-direction: column;
            gap: 2rem;
            /* Ensure themes apply correctly */
            height: 100%;
        }

        @media (max-width: 1024px) {
            .split-container {
                flex-direction: column;
            }
            .lightning-divider {
                /* Hide divider on mobile */
                display: none;
            }
        }

        .chart-container {
            background-color: var(--bg-secondary);
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            padding: 1rem;
            min-height: 400px;
            height: 500px; /* Fixed height for alignment */
        }

        /* --- Typography --- */
        h1 {
            font-size: 2.25rem;
            font-weight: 700;
        }
        h2 { /* SINA / INNA Titles */
            font-size: 1.75rem;
            font-weight: 700;
            color: var(--accent-primary);
            text-align: center;
            margin-bottom: 0.5rem;
            transition: color 0.3s ease;
        }
        h3 { /* Chart Titles */
            font-size: 1.25rem;
            font-weight: 600;
            color: var(--text-primary);
            text-align: center;
            margin-bottom: 1rem;
        }
        label {
            display: block;
            font-size: 0.875rem;
            font-weight: 500;
            color: #9CA3AF; /* Always use light text on dark controls */
            margin-bottom: 0.5rem;
        }
        .epoch-label {
            font-weight: 700;
            color: #38bdf8; /* Light blue for epoch number */
            transition: color 0.3s ease;
        }

        /* --- Form Elements --- */
        select,
        input[type="range"] {
            width: 100%;
        }

        select {
            padding: 0.5rem;
            background-color: #374151;
            color: #F3F4F6;
            border: 1px solid #4B5563;
            border-radius: 0.375rem;
            font-size: 1rem;
        }

        /* --- Epoch Slider --- */
        input[type="range"] {
            -webkit-appearance: none;
            height: 8px;
            background: #4B5563; /* Dark track */
            border-radius: 5px;
            outline: none;
            opacity: 0.7;
            transition: opacity .2s, background-color 0.3s ease;
        }
        input[type="range"]:hover {
            opacity: 1;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #38bdf8; /* Light blue thumb */
            border-radius: 50%;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #38bdf8; /* Light blue thumb */
            border-radius: 50%;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        
        /* --- Message Area --- */
        #messageArea {
            display: none;
            padding: 1rem;
            margin-bottom: 1.5rem;
            border-radius: 0.5rem;
            background-color: #FDE68A; /* Yellow for loading */
            color: #713F12; /* Dark yellow text */
            font-weight: 500;
        }
        #messageArea.visible {
            display: block;
        }
        #messageArea.error {
            background-color: #FECACA; /* Red for error */
            color: #7F1D1D; /* Dark red text */
        }
        
    </style>
</head>
<body>

    <div class="container">
        <header class="header">
            <h1 id="main-title">SINA vs. INNA Visualizer</h1>
        </header>

        <!-- Controls Section -->
        <div class="controls">
            <div class="control-group">
                <label for="datasetSelector">Select Dataset:</label>
                <select id="datasetSelector"></select>
            </div>
            <div class="control-group">
                <label for="epochSlider">Select Epoch: <span id="epochLabel" class="epoch-label">1</span></label>
                <input type="range" id="epochSlider" min="1" max="1" value="1">
            </div>
        </div>
        
        <!-- Loading/Error Message -->
        <div id="messageArea"></div>

        <!-- Charts Section -->
        <div class="split-container">
            
            <!-- SINA Side -->
            <div id="sina-side" class="split-side theme-sina">
                <h2>SINA</h2>
                <div class="chart-container">
                    <h3>Validation Accuracy (by Alpha vs. Beta)</h3>
                    <div id="accuracyChartSina" style="width:100%; height: 400px;"></div>
                </div>
                <div class="chart-container">
                    <h3>Loss (by Alpha vs. Beta)</h3>
                    <div id="lossChartSina" style="width:100%; height: 400px;"></div>
                </div>
            </div>

            <!-- Lightning Divider -->
            <div class="lightning-divider"></div>

            <!-- INNA Side -->
            <div id="inna-side" class="split-side theme-inna">
                <h2>INNA</h2>
                <div class="chart-container">
                    <h3>Validation Accuracy (by Alpha vs. Beta)</h3>
                    <div id="accuracyChartInna" style="width:100%; height: 400px;"></div>
                </div>
                <div class="chart-container">
                    <h3>Loss (by Alpha vs. Beta)</h3>
                    <div id="lossChartInna" style="width:100%; height: 400px;"></div>
                </div>
            </div>

        </div>
    </div>

    <script>
        // --- GLOBAL STATE ---
        const datasets = {
            sina: [],
            inna: []
        };
        let currentEpoch = 1;
        let currentDataset = ''; // New state variable

        // --- DOM ELEMENTS ---
        const epochSlider = document.getElementById('epochSlider');
        const epochLabel = document.getElementById('epochLabel');
        const datasetSelector = document.getElementById('datasetSelector'); // New DOM element
        const messageArea = document.getElementById('messageArea');
        
        const sinaSide = document.getElementById('sina-side');
        const lossChartSina = document.getElementById('lossChartSina');
        const accuracyChartSina = document.getElementById('accuracyChartSina');
        
        const innaSide = document.getElementById('inna-side');
        const lossChartInna = document.getElementById('lossChartInna');
        const accuracyChartInna = document.getElementById('accuracyChartInna');

        // --- PLOTLY CONFIG ---
        
        /**
         * Gets dynamic Plotly layout based on the current theme element
         */
        const getPlotlyLayout = (title, zAxisTitle, themeElement) => {
            // Read CSS variables at runtime from the specific theme element
            const style = getComputedStyle(themeElement);
            const textColor = style.getPropertyValue('--text-primary');
            const gridColor = style.getPropertyValue('--plot-grid');
            const bgColor = style.getPropertyValue('--plot-bg');
            const paperColor = 'rgba(0,0,0,0)'; // Always transparent

            return {
                title: { text: title, font: { color: textColor } },
                paper_bgcolor: paperColor,
                plot_bgcolor: paperColor, // Make plot background transparent
                font: { color: textColor },
                autosize: true,
                margin: { l: 40, r: 40, b: 40, t: 60 },
                scene: {
                    bgcolor: bgColor, // Use semi-transparent background for the scene
                    xaxis: { 
                        title: 'Alpha', 
                        gridcolor: gridColor, 
                        backgroundcolor: 'rgba(0,0,0,0)',
                        zerolinecolor: gridColor,
                        titlefont: { color: textColor },
                        tickfont: { color: textColor }
                    },
                    yaxis: { 
                        title: 'Beta', 
                        gridcolor: gridColor,
                        backgroundcolor: 'rgba(0,0,0,0)',
                        zerolinecolor: gridColor,
                        titlefont: { color: textColor },
                        tickfont: { color: textColor }
                    },
                    zaxis: { 
                        title: zAxisTitle, 
                        gridcolor: gridColor,
                        backgroundcolor: 'rgba(0,0,0,0)',
                        zerolinecolor: gridColor,
                        titlefont: { color: textColor },
                        tickfont: { color: textColor }
                    },
                    camera: {
                        eye: { x: 1.8, y: 1.8, z: 0.5 }
                    }
                }
            };
        };
        
        const plotlyConfig = {
            responsive: true,
            displayModeBar: false
        };

        // --- INITIALIZATION ---
        window.onload = () => {
            initializeApp();
        };

        async function initializeApp() {
            showMessage("Loading SINA & INNA datasets...", "loading");
            
            try {
                // Fetch both CSV files in parallel
                const [sinaResults, innaResults] = await Promise.all([
                    fetchCsv('epoch_sweep_results_sina.csv'),
                    fetchCsv('epoch_sweep_results_inna.csv')
                ]);

                // Ensure 'dataset' column exists or handle it
                datasets.sina = sinaResults.data.map(row => ({...row, dataset: row.dataset || 'default'}));
                datasets.inna = innaResults.data.map(row => ({...row, dataset: row.dataset || 'default'}));


                if (!datasets.sina.length && !datasets.inna.length) {
                    throw new Error("Both datasets are empty or failed to load.");
                }
                
                console.log("SINA data loaded:", datasets.sina.length, "rows");
                console.log("INNA data loaded:", datasets.inna.length, "rows");

                // Set up UI
                populateDatasetSelector(); // New function
                setupEventListeners();
                updateEpochSlider(); // Must run after populateDatasetSelector sets currentDataset
                drawCharts(); // Draw initial charts
                hideMessage();

            } catch (error) {
                console.error("Initialization error:", error);
                showMessage(`Error loading data: ${error.message}. Please check file paths and CSV format.`, "error");
            }
        }

        /**
         * Helper function to fetch and parse a CSV from a URL
         * Returns a Promise that resolves with PapaParse results
         */
        function fetchCsv(url) {
            return new Promise((resolve, reject) => {
                Papa.parse(url, {
                    download: true,
                    header: true,
                    skipEmptyLines: true,
                    dynamicTyping: true, // Automatically converts numbers
                    complete: (results) => {
                        if (results.errors.length) {
                            reject(new Error(`Error parsing ${url}: ${results.errors[0].message}`));
                        } else {
                            // Check for 'dataset' column, add 'default' if missing
                            if (results.data.length > 0 && results.data[0].dataset === undefined) {
                                console.warn(`'dataset' column not found in ${url}. Using 'default'.`);
                                results.data.forEach(row => row.dataset = 'default');
                            }
                            resolve(results);
                        }
                    },
                    error: (error, file) => {
                        reject(new Error(`Could not fetch or parse ${url}: ${error.message}`));
                    }
                });
            });
        }

        // --- EVENT LISTENERS ---
        function setupEventListeners() {
            epochSlider.addEventListener('input', handleSliderChange);
            datasetSelector.addEventListener('change', handleDatasetChange); // New listener
            
            // Handle window resize for Plotly
            window.addEventListener('resize', () => {
                if (lossChartSina.data) Plotly.Plots.resize(lossChartSina);
                if (accuracyChartSina.data) Plotly.Plots.resize(accuracyChartSina);
                if (lossChartInna.data) Plotly.Plots.resize(lossChartInna);
                if (accuracyChartInna.data) Plotly.Plots.resize(accuracyChartInna);
            });
        }
        
        function handleDatasetChange(event) {
            currentDataset = event.target.value;
            console.log("Dataset changed to:", currentDataset);
            updateEpochSlider(); // Update slider range for new dataset
            drawCharts(); // Redraw all charts
        }

        function handleSliderChange(event) {
            currentEpoch = parseInt(event.target.value);
            epochLabel.textContent = currentEpoch;
            drawCharts(); // Redraw all charts on slider input
        }
        
        // --- UI & DATA UPDATES ---

        function showMessage(message, type = "loading") {
            messageArea.textContent = message;
            messageArea.className = 'visible';
            if (type === 'error') {
                messageArea.classList.add('error');
            }
        }
        
        function hideMessage() {
            messageArea.className = '';
        }
        
        function populateDatasetSelector() {
            const sinaDatasets = new Set(datasets.sina.map(row => row.dataset));
            const innaDatasets = new Set(datasets.inna.map(row => row.dataset));
            const allDatasetNames = [...new Set([...sinaDatasets, ...innaDatasets])];
            
            console.log("Found datasets:", allDatasetNames);
            
            datasetSelector.innerHTML = ''; // Clear existing options
            allDatasetNames.forEach(name => {
                const option = document.createElement('option');
                option.value = name;
                option.textContent = name.charAt(0).toUpperCase() + name.slice(1); // Capitalize
                datasetSelector.appendChild(option);
            });
            
            if (allDatasetNames.length > 0) {
                currentDataset = allDatasetNames[0]; // Set default dataset
            } else {
                console.warn("No datasets found to populate selector.");
            }
        }
        
        function updateEpochSlider() {
            if (!currentDataset) {
                console.warn("No dataset selected, cannot update epoch slider.");
                return;
            }

            // Filter by current dataset *first*
            const sinaEpochs = datasets.sina
                .filter(row => row.dataset === currentDataset)
                .map(row => row.epoch);
            const innaEpochs = datasets.inna
                .filter(row => row.dataset === currentDataset)
                .map(row => row.epoch);
                
            const allEpochs = [...new Set([...sinaEpochs, ...innaEpochs])];
            
            if (allEpochs.length === 0) {
                console.warn("No data for dataset:", currentDataset);
                epochSlider.min = 1;
                epochSlider.max = 1;
                epochSlider.value = 1;
                epochLabel.textContent = 1;
                return;
            }
            
            const minEpoch = Math.min(...allEpochs);
            const maxEpoch = Math.max(...allEpochs);
            
            epochSlider.min = minEpoch;
            epochSlider.max = maxEpoch;
            
            if (currentEpoch < minEpoch || currentEpoch > maxEpoch) {
                currentEpoch = minEpoch;
            }
            
            epochSlider.value = currentEpoch;
            epochLabel.textContent = currentEpoch;
        }

        // --- CHART DRAWING ---

        /**
         * Helper function to build the Z-matrices for Plotly
         */
        function buildZMatrices(filteredData, alphas, betas) {
            const lossZ = [];
            const accuracyZ = [];

            for (const beta of betas) {
                const lossRow = [];
                const accuracyRow = [];
                for (const alpha of alphas) {
                    const point = filteredData.find(d => d.alpha === alpha && d.beta === beta);
                    if (point) {
                        lossRow.push(point.loss);
                        accuracyRow.push(point.val_accuracy);
                    } else {
                        lossRow.push(null); // Plotly handles gaps
                    }
                }
                lossZ.push(lossRow);
                accuracyZ.push(accuracyRow);
            }
            return { lossZ, accuracyZ };
        }
        
        function drawCharts() {
            if (!currentDataset) {
                console.warn("drawCharts called, but no dataset is selected.");
                return;
            }

            // --- Process SINA ---
            const filteredDataSina = datasets.sina.filter(row => 
                row.epoch === currentEpoch && row.dataset === currentDataset
            );
            
            if (filteredDataSina.length > 0) {
                const alphasSina = [...new Set(filteredDataSina.map(d => d.alpha))].sort((a, b) => a - b);
                const betasSina = [...new Set(filteredDataSina.map(d => d.beta))].sort((a, b) => a - b);
                const { lossZ, accuracyZ } = buildZMatrices(filteredDataSina, alphasSina, betasSina);
                
                const lossTraceSina = {
                    x: alphasSina, y: betasSina, z: lossZ,
                    type: 'surface', colorscale: 'Viridis', reversescale: true, colorbar: { title: 'Loss' }
                };
                const accuracyTraceSina = {
                    x: alphasSina, y: betasSina, z: accuracyZ,
                    type: 'surface', colorscale: 'Viridis', colorbar: { title: 'Accuracy' }
                };

                Plotly.newPlot(accuracyChartSina, [accuracyTraceSina], getPlotlyLayout(`Accuracy (Epoch ${currentEpoch})`, 'Accuracy', sinaSide), plotlyConfig);
                Plotly.newPlot(lossChartSina, [lossTraceSina], getPlotlyLayout(`Loss (Epoch ${currentEpoch})`, 'Loss', sinaSide), plotlyConfig);
            } else {
                Plotly.purge(lossChartSina);
                Plotly.purge(accuracyChartSina);
            }

            // --- Process INNA ---
            const filteredDataInna = datasets.inna.filter(row => 
                row.epoch === currentEpoch && row.dataset === currentDataset
            );
            
            if (filteredDataInna.length > 0) {
                const alphasInna = [...new Set(filteredDataInna.map(d => d.alpha))].sort((a, b) => a - b);
                const betasInna = [...new Set(filteredDataInna.map(d => d.beta))].sort((a, b) => a - b);
                const { lossZ, accuracyZ } = buildZMatrices(filteredDataInna, alphasInna, betasInna);
                
                const lossTraceInna = {
                    x: alphasInna, y: betasInna, z: lossZ,
                    type: 'surface', colorscale: 'Viridis', reversescale: true, colorbar: { title: 'Loss' }
                };
                const accuracyTraceInna = {
                    x: alphasInna, y: betasInna, z: accuracyZ,
                    type: 'surface', colorscale: 'Viridis', colorbar: { title: 'Accuracy' }
                };
                
                Plotly.newPlot(accuracyChartInna, [accuracyTraceInna], getPlotlyLayout(`Accuracy (Epoch ${currentEpoch})`, 'Accuracy', innaSide), plotlyConfig);
                Plotly.newPlot(lossChartInna, [lossTraceInna], getPlotlyLayout(`Loss (Epoch ${currentEpoch})`, 'Loss', innaSide), plotlyConfig);
            } else {
                Plotly.purge(lossChartInna);
                Plotly.purge(accuracyChartInna);
            }
        }

    </script>

</body>
</html>
